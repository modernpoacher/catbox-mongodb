"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=void 0;var _mongodb=_interopRequireDefault(require("mongodb"));var _hoek=_interopRequireDefault(require("@hapi/hoek"));var _boom=require("@hapi/boom");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const defaults={uri:'mongodb://127.0.0.1:27017/?maxPoolSize=5'};const settings={useNewUrlParser:true,useUnifiedTopology:true,connectTimeoutMS:1000,serverSelectionTimeoutMS:1000};class Connection{constructor(options){_hoek.default.assert(this instanceof Connection,'MongoDB cache client must be instantiated using new');this.collections={};this.isConnected=false;this.isConnectionStarted=false;this.settings=this.getSettings(options);return this;}getSettings(options){_hoek.default.assert(options.partition!=='admin'&&options.partition!=='local'&&options.partition!=='config','Cache partition name cannot be "admin", "local", or "config" when using MongoDB');_hoek.default.assert(options.partition.length<64,'Cache partition must be less than 64 bytes when using MongoDB');const settings=_hoek.default.applyToDefaults(defaults,options);settings.uri=settings.uri.replace(/(mongodb:\/\/[^/]*)([^?]*)(.*)/,`$1/${settings.partition}$3`);return settings;}async start(){if(this.isConnected){return;}if(this.isConnectionStarted){return;}this.isConnectionStarted=true;try{this.client=await _mongodb.default.MongoClient.connect(this.settings.uri,settings);this.db=this.client.db();this.isConnected=true;}catch(e){this.isConnectionStarted=false;this.isConnected=false;throw e;}}async stop(){if(this.client){await this.client.close();delete this.client;delete this.db;this.collections={};this.isConnectionStarted=false;this.isConnected=false;}}isReady(){return this.isConnected;}validateSegmentName(name){if(!name){throw new _boom.Boom('Empty string');}if(name.includes('\0')){throw new _boom.Boom('Includes null character');}if(name.startsWith('system.')){throw new _boom.Boom('Begins with "system."');}if(name.includes('$')){throw new _boom.Boom('Contains "$"');}if(name.length+this.settings.partition.length>=100){throw new _boom.Boom('Segment and partition name lengths exceeds 100 characters');}return null;}async getCollection(name){if(!this.isConnected){throw new _boom.Boom('Connection not ready');}if(!name){throw new _boom.Boom('Collection name missing');}if(this.collections[name]){return this.collections[name];}const collection=await this.db.collection(name);await collection.createIndex({expiresAt:1},{expireAfterSeconds:0});this.collections[name]=collection;return collection;}async get({id,segment}){if(!this.isConnectionStarted){throw new _boom.Boom('Connection not started');}const collection=await this.getCollection(segment);const criteria={_id:id};const record=await collection.findOne(criteria);if(!record){return null;}if(!record.stored){throw new _boom.Boom('Incorrect record structure');}const envelope={item:record.value,stored:record.stored.getTime(),ttl:record.ttl};return envelope;}async set({id,segment},value,ttl){if(!this.isConnectionStarted){throw new _boom.Boom('Connection not started');}const collection=await this.getCollection(segment);const expiresAt=new Date();expiresAt.setMilliseconds(expiresAt.getMilliseconds()+ttl);const record={value,stored:new Date(),ttl,expiresAt};const criteria={_id:id};await collection.updateOne(criteria,{$set:record},{upsert:true,safe:true});}async drop({id,segment}){if(!this.isConnectionStarted){throw new _boom.Boom('Connection not started');}const collection=await this.getCollection(segment);const criteria={_id:id};await collection.deleteOne(criteria,{safe:true});}}exports.default=Connection;